[
{
	"uri": "//localhost:1313/vi/1-flat-file-databases/",
	"title": "Cơ sở dữ liệu dạng Flat-File",
	"tags": [],
	"description": "",
	"content": "Dữ liệu thường được mô tả bằng các mẫu cột và hàng. Các bảng tính như Microsoft Excel hoặc Google Sheets có thể được xuất thành tập tin .csv (Comma-Separated Values - Giá trị được phân tách bằng dấu phẩy). Khi bạn mở một tập tin .csv, bạn sẽ thấy rằng dữ liệu được lưu trữ trong một bảng duy nhất đại diện bằng một tập tin văn bản phẳng, do đó loại dữ liệu này được gọi là cơ sở dữ liệu dạng tập tin phẳng - Flat-File.\nPython hỗ trợ xử lý các tập tin .csv một cách tự nhiên. Để thực hành, trước tiên, hãy tải tập tin favorites.csv và tải nó lên môi trường làm việc của bạn trong cs50.dev. Sau đó, mở cửa sổ dòng lệnh, nhập code favorites.py và viết đoạn mã sau:\n# In ra tất cả các mục yêu thích trong tập tin CSV sử dụng csv.reader import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng reader reader = csv.reader(file) # Bỏ qua dòng tiêu đề next(reader) # Duyệt qua từng dòng trong tập tin CSV và in ra mục yêu thích for row in reader: print(row[1]) Chú ý rằng thư viện csv đã được nhập vào. Chúng ta đã tạo một đối tượng reader để lưu kết quả của csv.reader(file). Hàm csv.reader đọc từng dòng trong tập tin và lưu kết quả vào reader. print(row[1]) sẽ in ra ngôn ngữ yêu thích từ tập tin favorites.csv.\nBạn có thể cải thiện đoạn mã như sau:\n# Lưu mục yêu thích vào một biến import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng reader reader = csv.reader(file) # Bỏ qua dòng tiêu đề next(reader) # Duyệt qua từng dòng trong tập tin CSV và in ra mục yêu thích for row in reader: favorite = row[1] print(favorite) Ở đây, giá trị mục yêu thích được lưu vào biến favorite trước khi in ra. Cũng lưu ý rằng chúng ta đã sử dụng hàm next để bỏ qua dòng tiêu đề.\nKhắc phục lỗi chỉ mục Một nhược điểm của phương pháp trên là chúng ta giả định rằng row[1] luôn là mục yêu thích. Tuy nhiên, nếu các cột bị di chuyển thì sẽ xảy ra lỗi. Để khắc phục, bạn có thể sử dụng csv.DictReader, cho phép truy cập giá trị bằng tên cột:\n# In tất cả mục yêu thích bằng cách sử dụng csv.DictReader import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng DictReader reader = csv.DictReader(file) # Duyệt qua từng dòng trong tập tin CSV và in ra mục yêu thích for row in reader: favorite = row[\u0026#34;language\u0026#34;] print(favorite) Bạn cũng có thể viết gọn lại đoạn mã trên:\n# In tất cả mục yêu thích bằng cách sử dụng csv.DictReader import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng DictReader reader = csv.DictReader(file) # Duyệt qua từng dòng trong tập tin CSV và in ra mục yêu thích for row in reader: print(row[\u0026#34;language\u0026#34;]) Đếm số lượng Để đếm số lần xuất hiện của từng ngôn ngữ yêu thích trong tập tin .csv, bạn có thể làm như sau:\n# Đếm các ngôn ngữ yêu thích sử dụng các biến import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng DictReader reader = csv.DictReader(file) # Biến đếm scratch, c, python = 0, 0, 0 # Duyệt qua từng dòng trong tập tin CSV và đếm mục yêu thích for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite == \u0026#34;Scratch\u0026#34;: scratch += 1 elif favorite == \u0026#34;C\u0026#34;: c += 1 elif favorite == \u0026#34;Python\u0026#34;: python += 1 # In kết quả đếm print(f\u0026#34;Scratch: {scratch}\u0026#34;) print(f\u0026#34;C: {c}\u0026#34;) print(f\u0026#34;Python: {python}\u0026#34;) Cách này sử dụng các biến để đếm từng ngôn ngữ yêu thích. Bạn cũng có thể cải thiện mã nguồn bằng cách sử dụng từ điển để lưu trữ số lần xuất hiện:\n# Đếm các ngôn ngữ yêu thích bằng từ điển import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng DictReader reader = csv.DictReader(file) # Tạo biến đếm bằng từ điển counts = {} # Duyệt qua từng dòng trong tập tin CSV và đếm mục yêu thích for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 # In kết quả đếm for favorite in counts: print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) Sắp xếp theo giá trị Python cho phép sắp xếp các giá trị trong từ điển bằng cách sử dụng hàm sorted:\n# Sắp xếp mục yêu thích theo giá trị import csv # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo đối tượng DictReader reader = csv.DictReader(file) # Biến đếm counts = {} # Duyệt qua từng dòng trong tập tin CSV và đếm mục yêu thích for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 # In kết quả sau khi sắp xếp for favorite in sorted(counts, key=counts.get, reverse=True): print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) Trong đoạn mã trên, key=counts.get giúp sắp xếp theo giá trị, và reverse=True sắp xếp từ cao đến thấp.\nPython có nhiều thư viện hỗ trợ xử lý dữ liệu như collections. Bạn có thể sử dụng Counter từ thư viện này để đơn giản hóa việc đếm như sau:\n# Sử dụng Counter để đếm các mục yêu thích import csv from collections import Counter # Mở tập tin CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: reader = csv.DictReader(file) # Đếm bằng Counter counts = Counter(row[\u0026#34;language\u0026#34;] for row in reader) # In kết quả for favorite, count in counts.most_common(): print(f\u0026#34;{favorite}: {count}\u0026#34;) "
},
{
	"uri": "//localhost:1313/vi/",
	"title": "CS50 Tuần 7",
	"tags": [],
	"description": "",
	"content": "CS50 Tuần 7 - SQL Tổng quan Chào mừng đến với tuần thứ 7. Tuần này, chúng ta sẽ thảo luận về SQL (Structured Query Language - Ngôn ngữ Truy vấn Có Cấu trúc). Chúng ta sẽ đi qua các nội dung sau đây.\nMục lục Cơ sở dữ liệu dạng Flat-File Cơ sở dữ liệu quan hệ SQL với Python Tấn công SQL Injection "
},
{
	"uri": "//localhost:1313/vi/2-relational-databases/",
	"title": "Cơ sở dữ liệu quan hệ",
	"tags": [],
	"description": "",
	"content": "Cơ sở dữ liệu quan hệ (Relational Databases) Các công ty lớn như Google, Twitter, và Meta đều sử dụng cơ sở dữ liệu quan hệ để lưu trữ thông tin ở quy mô lớn. Cơ sở dữ liệu quan hệ lưu trữ dữ liệu dưới dạng các bảng (tables), mỗi bảng chứa các dòng và cột. Bạn có thể thao tác với dữ liệu này bằng ngôn ngữ truy vấn có cấu trúc SQL với bốn lệnh cơ bản: Create, Read, Update, và Delete - được gọi tắt là CRUD.\nCác hoạt động chính trong cơ sở dữ liệu quan hệ: CRUD Các thao tác chính trong cơ sở dữ liệu quan hệ được gọi là CRUD, bao gồm:\nCreate: Tạo mới dữ liệu Read: Đọc dữ liệu Update: Cập nhật dữ liệu Delete: Xóa dữ liệu Chúng ta có thể tạo một cơ sở dữ liệu SQL bằng cách nhập lệnh sqlite3 favorites.db trên dòng lệnh. Khi được hỏi, bạn hãy nhấn y để xác nhận việc tạo cơ sở dữ liệu favorites.db. Sau khi xác nhận, bạn sẽ thấy giao diện của chương trình sqlite3. Để chuyển sqlite3 sang chế độ CSV, gõ lệnh:\n.mode csv Sau đó, bạn có thể nhập dữ liệu từ tập tin CSV bằng lệnh:\n.import favorites.csv favorites Tuy bạn không thấy gì thay đổi, nhưng dữ liệu đã được thêm vào cơ sở dữ liệu. Để xem cấu trúc của cơ sở dữ liệu, bạn có thể dùng lệnh:\n.schema Các lệnh cơ bản để truy vấn dữ liệu Bạn có thể đọc dữ liệu từ bảng bằng cú pháp:\nSELECT column FROM table; Ví dụ: lệnh sau sẽ duyệt qua từng dòng trong bảng favorites:\nSELECT * FROM favorites; Hoặc, để lấy một phần dữ liệu cụ thể hơn:\nSELECT language FROM favorites; SQL hỗ trợ nhiều lệnh để truy xuất dữ liệu, bao gồm:\nAVG: Tính giá trị trung bình COUNT: Đếm số lượng DISTINCT: Lấy ra các giá trị duy nhất LOWER: Chuyển đổi chuỗi thành chữ thường MAX: Lấy giá trị lớn nhất MIN: Lấy giá trị nhỏ nhất UPPER: Chuyển đổi chuỗi thành chữ in hoa Ví dụ:\nSELECT COUNT(language) FROM favorites; Lệnh này sẽ đếm số lần xuất hiện của mỗi ngôn ngữ trong bảng favorites. Bạn có thể sử dụng lệnh sau để đếm các ngôn ngữ riêng biệt:\nSELECT DISTINCT(language) FROM favorites; Để lấy tổng số lượng các ngôn ngữ riêng biệt, dùng lệnh:\nSELECT COUNT(DISTINCT(language)) FROM favorites; Các lệnh SQL nâng cao SQL cung cấp nhiều lệnh khác để tùy chỉnh truy vấn dữ liệu:\nWHERE: Thêm điều kiện để lọc dữ liệu LIKE: Tìm kiếm các kết quả gần đúng ORDER BY: Sắp xếp kết quả LIMIT: Giới hạn số lượng kết quả GROUP BY: Nhóm các kết quả lại với nhau Để viết chú thích trong SQL, chúng ta dùng --. Ngoài ra có các câu lệnh sau, để đếm số dòng có ngôn ngữ là C:\nSELECT COUNT(*) FROM favorites WHERE language = \u0026#39;C\u0026#39;; Bạn cũng có thể kết hợp nhiều điều kiện bằng lệnh AND:\nSELECT COUNT(*) FROM favorites WHERE language = \u0026#39;C\u0026#39; AND problem = \u0026#39;Hello, World\u0026#39;; Lệnh này sẽ đếm số lần xuất hiện của ngôn ngữ C với bài tập Hello, World.\nThêm và xóa dữ liệu trong cơ sở dữ liệu Để thêm dữ liệu vào cơ sở dữ liệu:\nINSERT INTO favorites (language, problem) VALUES (\u0026#39;SQL\u0026#39;, \u0026#39;Fiftyville\u0026#39;); Để xóa các dòng dữ liệu thỏa điều kiện:\nDELETE FROM favorites WHERE Timestamp IS NULL; Bạn cũng có thể sử dụng lệnh UPDATE để cập nhật dữ liệu:\nUPDATE favorites SET language = \u0026#39;SQL\u0026#39;, problem = \u0026#39;Fiftyville\u0026#39;; Lệnh này sẽ thay thế toàn bộ giá trị hiện tại bằng giá trị mới trong các dòng thỏa mãn điều kiện.\nVí dụ: Xây dựng cơ sở dữ liệu cho các chương trình TV. Hãy tưởng tượng rằng bạn muốn tạo một cơ sở dữ liệu để lưu trữ thông tin về các chương trình truyền hình. Bạn có thể tạo một bảng tính với các cột như title (tên chương trình), star (ngôi sao), và nhiều ngôi sao khác. Tuy nhiên, cách tiếp cận này có thể lãng phí không gian lưu trữ vì một số chương trình có rất ít diễn viên, trong khi số khác có rất nhiều.\nMột cách tiếp cận tốt hơn là phân tách dữ liệu thành nhiều bảng. Ví dụ:\nBảng shows: Chứa thông tin về các chương trình (với ID duy nhất cho mỗi chương trình). Bảng people: Chứa thông tin về diễn viên (với ID duy nhất cho mỗi diễn viên). Bảng stars: Liên kết các chương trình và diễn viên bằng cách sử dụng show_id và person_id. IMDb là một ví dụ tiêu biểu cho cách lưu trữ thông tin của các chương trình truyền hình và phim ảnh. Họ có một cơ sở dữ liệu bao gồm các bảng liên kết như: diễn viên, chương trình, biên kịch, thể loại, và xếp hạng. Mỗi bảng có mối liên hệ chặt chẽ với nhau.\nSau khi tải về tập tin shows.db, bạn có thể mở nó bằng lệnh:\nsqlite3 shows.db Quan hệ giữa bảng shows và ratings có mối quan hệ như sau:\nBạn có thể kiểm tra mối quan hệ giữa 2 bảng trên bằng cách nhập các lệnh như:\nSELECT * FROM ratings LIMIT 10; Hoặc:\nSELECT * FROM shows LIMIT 10; Lệnh .schema sẽ hiển thị cấu trúc của cơ sở dữ liệu, bao gồm các bảng và các trường trong từng bảng.\nMỗi bảng có một trường id duy nhất, gọi là primary key (khóa chính). Trường show_id trong bảng genres là foreign key (khóa ngoại) liên kết với trường id trong bảng shows. Khóa chính được sử dụng để định danh duy nhất một bản ghi trong bảng, trong khi khóa ngoại được sử dụng để liên kết dữ liệu giữa các bảng khác nhau.\nCác kiểu dữ liệu trong SQLite SQLite hỗ trợ năm loại dữ liệu cơ bản:\nBLOB: Lưu trữ dữ liệu nhị phân (hình ảnh, tệp tin). INTEGER: Số nguyên. NUMERIC: Số liệu với định dạng đặc biệt (ví dụ như ngày tháng). REAL: Số thực (float). TEXT: Chuỗi ký tự. Bạn có thể thêm các ràng buộc đặc biệt cho từng cột như:\nNOT NULL: Cột không được phép để trống. UNIQUE: Giá trị của cột phải là duy nhất. Ví dụ:\nSELECT * FROM stars LIMIT 10; Kết hợp bảng với JOIN Bạn có thể kết hợp hai hoặc nhiều bảng bằng cách sử dụng JOIN. Ví dụ:\nSELECT * FROM shows JOIN ratings ON shows.id = ratings.show_id WHERE rating \u0026gt;= 6.0 LIMIT 10; Lệnh trên kết hợp hai bảng shows và ratings để lấy các chương trình có xếp hạng từ 6.0 trở lên.\nChỉ mục Chỉ mục (Index) giúp tăng tốc độ truy vấn bằng cách tạo ra các cấu trúc dữ liệu đặc biệt. Tạo chỉ mục cho cột title bằng lệnh:\nCREATE INDEX title_index ON shows (title); Câu lệnh này yêu cầu sqlite3 tạo một chỉ mục và thực hiện một số tối ưu hóa đặc biệt liên quan đến cột title. Điều này tạo ra một cấu trúc dữ liệu gọi là B Tree, một cấu trúc dữ liệu có hình dạng tương tự như cây nhị phân. Tuy nhiên, khác với cây nhị phân, có thể có nhiều hơn hai nút con.\nSau khi tạo chỉ mục, truy vấn sẽ chạy nhanh hơn đáng kể:\nSELECT * FROM shows WHERE title = \u0026#39;The Office\u0026#39;; Tuy nhiên, việc tạo chỉ mục cho tất cả các cột có thể tốn nhiều không gian lưu trữ, vì vậy bạn cần cân nhắc khi sử dụng.\n"
},
{
	"uri": "//localhost:1313/vi/3-sql-in-python/",
	"title": "SQL với Python",
	"tags": [],
	"description": "",
	"content": "Để hỗ trợ trong quá trình làm việc với SQL trong khóa học này, thư viện CS50 có thể được sử dụng như sau trong mã của bạn:\nfrom cs50 import SQL Tương tự như các lần sử dụng thư viện CS50 trước đây, thư viện này sẽ hỗ trợ các bước phức tạp trong việc sử dụng SQL trong mã Python của bạn.\nBạn có thể đọc thêm về chức năng SQL của thư viện CS50 trong tài liệu.\nNhớ lại trong ví dụ trước, tập tin favorites.py được viết lại như sau:\n# Đếm số lượng cụ thể import csv from collections import Counter # Mở tệp CSV with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Tạo DictReader reader = csv.DictReader(file) # Đếm counts = Counter() # Duyệt qua tệp CSV và đếm các mục yêu thích for row in reader: favorite = row[\u0026#34;problem\u0026#34;] counts[favorite] += 1 # In số lượng favorite = input(\u0026#34;Mục yêu thích: \u0026#34;) print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) Hãy sửa đổi mã của bạn như sau:\n# Tìm kiếm mức độ phổ biến của một vấn đề trong cơ sở dữ liệu import csv from cs50 import SQL # Mở cơ sở dữ liệu db = SQL(\u0026#34;sqlite:///favorites.db\u0026#34;) # Yêu cầu người dùng nhập mục yêu thích favorite = input(\u0026#34;Mục yêu thích: \u0026#34;) # Tìm kiếm tiêu đề rows = db.execute(\u0026#34;SELECT COUNT(*) AS n FROM favorites WHERE problem LIKE ?\u0026#34;, favorite) # Lấy hàng đầu tiên (và duy nhất) row = rows[0] # In mức độ phổ biến print(row[\u0026#34;n\u0026#34;]) Lưu ý rằng db = SQL(\u0026quot;sqlite:///favorites.db\u0026quot;) cung cấp cho Python vị trí của tệp cơ sở dữ liệu. Sau đó, dòng bắt đầu bằng rows thực hiện các lệnh SQL bằng cách sử dụng db.execute. Thực tế, lệnh này truyền cú pháp trong dấu ngoặc kép cho hàm db.execute. Chúng ta có thể thực hiện bất kỳ lệnh SQL nào bằng cú pháp này.\nHơn nữa, lưu ý rằng rows được trả về dưới dạng một danh sách các từ điển. Trong trường hợp này, chỉ có một kết quả, một hàng, được trả về cho danh sách rows dưới dạng một từ điển.\nTình trạng Race (Race Conditions) Việc sử dụng SQL đôi khi có thể dẫn đến một số vấn đề.\nBạn có thể tưởng tượng một trường hợp mà nhiều người dùng có thể truy cập cùng một cơ sở dữ liệu và thực hiện các lệnh cùng một lúc.\nĐiều này có thể dẫn đến những lỗi mà mã bị gián đoạn bởi hành động của người khác, và có thể dẫn đến mất dữ liệu.\nCác tính năng tích hợp sẵn của SQL như BEGIN TRANSACTION, COMMIT, và ROLLBACK giúp tránh một số vấn đề tình trạng race này.\n"
},
{
	"uri": "//localhost:1313/vi/4-injection-attacks/",
	"title": "Tấn công SQL Injection",
	"tags": [],
	"description": "",
	"content": "Một trong những vấn đề thường gặp trong các ứng dụng SQL thực tế là tấn công SQL Injection. Đây là một hình thức tấn công trong đó kẻ xấu có thể chèn mã SQL độc hại vào hệ thống thông qua các đầu vào của người dùng.\nVí dụ về tấn công SQL Injection Hãy xem xét một màn hình đăng nhập đơn giản:\nNếu mã nguồn của hệ thống không có các biện pháp bảo vệ phù hợp, kẻ xấu có thể dễ dàng chèn mã SQL độc hại. Hãy xem xét ví dụ sau:\nrows = db.execute(\u0026#34;SELECT COUNT(*) FROM users WHERE username = ? AND password = ?\u0026#34;, username, password) Ở đây, các dấu chấm hỏi (?) đóng vai trò như các placeholder giúp đảm bảo rằng mọi dữ liệu người dùng nhập vào sẽ được xác thực trước khi được đưa vào câu truy vấn SQL. Điều này giúp ngăn chặn các đoạn mã độc hại chèn vào hệ thống.\nKhông sử dụng chuỗi định dạng trong truy vấn Bạn không bao giờ nên sử dụng chuỗi định dạng (formatted strings) trong các câu lệnh truy vấn như ví dụ dưới đây hoặc tin tưởng vào bất kỳ đầu vào nào từ người dùng mà không kiểm tra kỹ.\nrows = db.execute(f\u0026#34;SELECT * FROM users WHERE username = \u0026#39;{username}\u0026#39; AND password = \u0026#39;{password}\u0026#39;\u0026#34;) Cách viết trên dễ dẫn đến nguy cơ tấn công SQL Injection. Thay vào đó, bạn nên sử dụng cú pháp có dấu chấm hỏi (?) như trong ví dụ trước.\nTính năng bảo vệ của thư viện CS50 Khi bạn sử dụng thư viện CS50, thư viện sẽ tự động xử lý và loại bỏ các ký tự nguy hiểm có khả năng gây ra tấn công SQL Injection. Thư viện này sẽ đảm bảo rằng các đoạn mã do người dùng nhập vào sẽ được xử lý an toàn trước khi truyền vào truy vấn SQL.\nVí dụ:\nrows = db.execute(\u0026#34;SELECT COUNT(*) FROM users WHERE username = ? AND password = ?\u0026#34;, username, password) Đoạn mã trên không chỉ giúp ngăn chặn các cuộc tấn công SQL Injection mà còn đảm bảo rằng dữ liệu đầu vào được xử lý an toàn, tránh rủi ro bảo mật.\nVậy là kết thúc tuần 7 ^^\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]