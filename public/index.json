[
{
	"uri": "//localhost:1313/",
	"title": "CS50 Week 7",
	"tags": [],
	"description": "",
	"content": "CS50 Week 7 - SQL Overall Welcome to week 7. On this week, we are going to discuss SQL - Structured Query Language. We will go through these following contents.\nContent Flat-file Databases Relational Databases SQL in Python Injection Attacks "
},
{
	"uri": "//localhost:1313/1-flat-file-databases/",
	"title": "Flat-file Databases",
	"tags": [],
	"description": "",
	"content": "Data can often be described in patterns of columns and rows. Spreadsheets like those created in Microsoft Excel and Google Sheets can be outputted to a csv or comma-separated values file.\nIf you look at a csv file, youâ€™ll notice that the file is flat in that all of our data is stored in a single table represented by a text file. We call this form of data a flat-file database.\nPython comes with native support for csv files. First, download favorites.csv and upload it to your file explorer inside cs50.dev. Second, in your terminal window, type code favorites.py and write code as follows:\n# Prints all favorites in CSV using csv.reader import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create reader reader = csv.reader(file) # Skip header row next(reader) # Iterate over CSV file, printing each favorite for row in reader: print(row[1]) Notice that the csv library is imported. Further, we created a reader that will hold the result of csv.reader(file). The csv.reader function reads each row from the file, and in our code we store the results in reader. print(row[1]), therefore, will print the language from the favorites.csv file.\nYou can improve your code as follows:\n# Stores favorite in a variable import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create reader reader = csv.reader(file) # Skip header row next(reader) # Iterate over CSV file, printing each favorite for row in reader: favorite = row[1] print(favorite) Notice that favorite is stored and then printed. Also notice that we use the next function to skip to the next line of our reader. One of the disadvantages of the above approach is that we are trusting that row[1] is always the favorite. However, what would happen if the columns have been moved around?\nWe can fix this potential issue. Python also allows you to index by the keys of a list. Modify your code as follows:\n# Prints all favorites in CSV using csv.DictReader import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Iterate over CSV file, printing each favorite for row in reader: favorite = row[\u0026#34;language\u0026#34;] print(favorite) Notice that this example directly utilizes the language key in the print statement. This could be further simplified to:\n# Prints all favorites in CSV using csv.DictReader import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Iterate over CSV file, printing each favorite for row in reader: print(row[\u0026#34;language\u0026#34;]) To count the number of favorite languages expressed in the csv file, we can do the following:\n# Counts favorites using variables import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Counts scratch, c, python = 0, 0, 0 # Iterate over CSV file, counting favorites for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite == \u0026#34;Scratch\u0026#34;: scratch += 1 elif favorite == \u0026#34;C\u0026#34;: c += 1 elif favorite == \u0026#34;Python\u0026#34;: python += 1 # Print counts print(f\u0026#34;Scratch: {scratch}\u0026#34;) print(f\u0026#34;C: {c}\u0026#34;) print(f\u0026#34;Python: {python}\u0026#34;) Notice that each language is counted using if statements. Further notice the double equal == signs in those if statements. Python allows us to use a dictionary to count the counts of each language. Consider the following improvement upon our code:\n# Counts favorites using dictionary import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Counts counts = {} # Iterate over CSV file, counting favorites for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 # Print counts for favorite in counts: print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) Notice that the value in counts with the key favorite is incremented when it exists already. If it does not exist, we define counts[favorite] and set it to 1. Further, the formatted string has been improved to present the counts[favorite].\nPython also allows sorting counts. Improve your code as follows:\n# Sorts favorites by key import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Counts counts = {} # Iterate over CSV file, counting favorites for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 # Print counts for favorite in sorted(counts): print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) If you look at the parameters for the sorted function in the Python documentation, you will find it has many built-in parameters. You can leverage some of these built-in parameters as follows:\n# Sorts favorites by value using .get import csv # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Counts counts = {} # Iterate over CSV file, counting favorites for row in reader: favorite = row[\u0026#34;language\u0026#34;] if favorite in counts: counts[favorite] += 1 else: counts[favorite] = 1 # Print counts for favorite in sorted(counts, key=counts.get, reverse=True): print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) Notice the arguments passed to sorted. The key argument allows you to tell Python the method you wish to use to sort items. In this case counts.get is used to sort by the values. reverse=True tells sorted to sort from largest to smallest.\nPython has numerous libraries that we can utilize in our code. One of these libraries is collections, from which we can import Counter. Counter will allow you to access the counts of each language without the headaches of all the if statements seen in our previous code. You can implement as follows:\n# Sorts favorites by value using .get import csv from collections import Counter # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Counts counts = Counter() # Iterate over CSV file, counting favorites for row in reader: favorite = row[\u0026#34;language\u0026#34;] counts[favorite] += 1 # Print counts for favorite, count in counts.most_common(): print(f\u0026#34;{favorite}: {count}\u0026#34;) Notice how counts = Counter() enables the use of this imported Counter class from collections.\n"
},
{
	"uri": "//localhost:1313/2-relational-databases/",
	"title": "Relational Databases",
	"tags": [],
	"description": "",
	"content": "Google, Twitter, and Meta all use relational databases to store their information at scale. Relational databases store data in rows and columns in structures called tables. SQL allows for four types of commands:\nCreate Read Update Delete These four operations are affectionately called CRUD. We can create a SQL database at the terminal by typing sqlite3 favorites.db. Upon being prompted, we will agree that we want to create favorites.db by pressing y.\nYou will notice a different prompt as we are now inside a program called sqlite3.\nWe can put sqlite3 into csv mode by typing\n.mode csv Then, we can import our data from our csv file by typing\n.import favorites.csv favorites It seems that nothing has happened but we successfully imported our data.\nTo see the structure of the database, we can type\n.schema We can read items from a table using the syntax\nSELECT columns FROM table For example, we can iterate every row in favorites\nSELECT * FROM favorites; We can get a subset of the data using the command\nSELECT language FROM favorites; Common Commands SQL supports many commands to access data, including:\nAVG COUNT DISTINCT LOWER MAX MIN UPPER For example, you can count all rows of favorites by typing\nSELECT COUNT(language) FROM favorites; Further, you can type to get a list of the individual languages within the database, type\nSELECT DISTINCT(language) FROM favorites; You could even get a distinct count of those:\nSELECT COUNT(DISTINCT(language)) FROM favorites; SQL offers additional commands we can utilize in our queries:\nWHERE \u0026ndash; adding a Boolean expression to filter our data LIKE \u0026ndash; filtering responses more loosely ORDER BY \u0026ndash; ordering responses LIMIT \u0026ndash; limiting the number of responses GROUP BY \u0026ndash; grouping responses together Notice that we use -- to write a comment in SQL. For example, we can execute\nSELECT COUNT(*) FROM favorites WHERE language = \u0026#39;C\u0026#39;; A count is presented.\nFurther, we could type\nSELECT COUNT(*) FROM favorites WHERE language = \u0026#39;C\u0026#39; AND problem = \u0026#39;Hello, World; Notice how the AND is utilized to narrow our results.\nSimilarly, we could execute\nSELECT language, COUNT(*) FROM favorites GROUP BY language; This would offer a temporary table that would show the language and count.\nWe could improve this by typing\nSELECT language, COUNT(*) FROM favorites GROUP BY language ORDER BY COUNT(*); This will order the resulting table by the count. We can also INSERT into a SQL database utilizing the form\nINSERT INTO table (column...) VALUES(value, ...); We can execute\nINSERT INTO favorites (language, problem) VALUES (\u0026#39;SQL\u0026#39;, \u0026#39;Fiftyville\u0026#39;); DELETE allows you to delete parts of your data. For example, you could:\nDELETE FROM favorites WHERE Timestamp IS NULL; We can also utilize the UPDATE command to update your data.\nFor example, you can execute\nUPDATE favorites SET language = \u0026#39;SQL\u0026#39;, problem = \u0026#39;Fiftyville\u0026#39;; This will result in overwriting all previous statements where C was the favorite programming language.\nNotice that these queries have immense power. Accordingly, in the real-world setting, you should consider who has permissions to execute certain commands.\nExample We can imagine a database that we might want to create to catalog various TV shows. We could create a spreadsheet with columns like title, star, star, and more stars. A problem with this approach is this approach has a lot of wasted space. Some shows may have one star. Others may have dozens.\nWe could separate our database into multiple sheets. We could have a shows sheet and a people sheet. On the people sheet, each person could have a unique id. On the shows sheet, each show could have a unique id too. On a third sheet called stars we could relate how each show has people for each show by having a show_id and person_id. While this is an improvement, this is not an ideal database.\nIMDb offers a database of people, shows, writers, stars, genres, and ratings. Each of these tables is related to one another as follows:\nAfter downloading shows.db, you can execute sqlite3 shows.db in your terminal window.\nLetâ€™s zero in on the relationship between two tables within the database called shows and ratings. The relationship between these two tables can be illustrated as follows:\nTo illustrate the relationship between these tables, we could execute the following command: SELECT * FROM ratings LIMIT 10;. Examining the output, we could execute SELECT * FROM shows LIMIT 10;.\nTo understand the database, upon executing .schema you will find not only each of the tables but the individual fields inside each of these fields.\nAs you can see, shows has an id field. The genres table has a show_id field which has data that is common between it and the shows table.\nFurther, show_id exists in all of the tables. In the shows table, it is simply called id. This common field between all the fields is called a key. Primary keys are used to identify a unique record in a table. Foreign keys are used to build relationships between tables by pointing to the primary key in another table.\nBy storing data in a relational database, as above, data can be more efficiently stored.\nIn sqlite, we have five datatypes, including:\nBLOB \u0026ndash; binary large objects that are groups of ones and zeros INTEGER \u0026ndash; an integer NUMERIC \u0026ndash; for numbers that are formatted specially like dates REAL \u0026ndash; like a float TEXT \u0026ndash; for strings and the like Additionally, columns can be set to add special constraints: NOT NULL, UNIQUE\nWe could execute\nSELECT * FROM stars LIMIT 10; show_id is a foreign key in this final query because show_id corresponds to the unique id field in shows. person_id corresponds to the unique id field in the people column.\nWe can further play with this data to understand these relationships. Execute\nSELECT * FROM ratings; There are a lot of ratings!\nWe can further limit this data down by executing\nSELECT show_id FROM ratings WHERE rating \u0026gt;= 6.0 LIMIT 10; From this query, you can see that there are 10 shows presented. However, we donâ€™t know what show each show_id represents.\nYou can discover what shows these are by executing\nSELECT * FROM shows WHERE id = 626124; We can further our query to be more efficient by executing:\nSELECT title FROM shows WHERE id IN ( SELECT show_id FROM ratings WHERE rating \u0026gt;= 6.0 LIMIT 10 ) Notice that this query nests together two queries. An inner query is used by an outer query.\nJOINs We are pulling data from shows and ratings. How could we combine tables temporarily? Tables could be joined together using the JOIN command. Execute the following command:\nSELECT * FROM shows JOIN ratings on shows.id = ratings.show_id WHERE rating \u0026gt;= 6.0 LIMIT 10; Notice this results in a wider table than we have previously seen. Where the previous queries have illustrated the one-to-one relationship between these keys, letâ€™s examine some one-to-many relationships. Focusing on the genres table, execute the following:\nSELECT * FROM genres LIMIT 10; Notice how this provides us a sense of the raw data. You might notice that one shows have three values. This is a one-to-many relationship.\nWe can learn more about the genres table by typing .schema genres. Execute the following command to learn more about the various comedies in the database:\nSELECT title FROM shows WHERE id IN ( SELECT show_id FROM genres WHERE genre = \u0026#39;Comedy\u0026#39; LIMIT 10 ); Notice how this produces a list of comedies, including Catweazle.\nTo learn more about Catweazle, by joining various tables through a join:\nSELECT * FROM shows JOIN genres ON shows.id = genres.show_id WHERE id = 63881; Notice that this results in a temporary table. It is fine to have duplicate table.\nA final relationship is a many-to-many relationship. We can learn more about the show The Office by executing the following command:\nSELECT person_id FROM stars WHERE show_id = ( SELECT id FROM shows WHERE title = \u0026#39;The Office\u0026#39; AND year = 2005 ); Notice that this results in a table that includes the person_ids of various stars. I could learn more about this group of actors by executing the following:\nSELECT name FROM people WHERE id IN ( SELECT person_id FROM stars WHERE show_id = ( SELECT id FROM shows WHERE title = \u0026#39;The Office\u0026#39; AND year = 2005 ) ); This results in a top-billed stars. We can further understand this data by executing:\nSELECT title from shows WHERE id IN ( SELECT show_id FROM stars WHERE person_id = ( SELECT id FROM people WHERE name = \u0026#39;Steve Carell\u0026#39; ) ); This results in a list of titles of shows wherein Steve Carell stared.\nThe wildcard % operator can be used to find all people whose names start with Steve C one could employ the syntax\nSELECT * FROM people WHERE name LIKE \u0026#39;Steve C%\u0026#39;; Indexes While relational databases have the ability to be more fast and more robust than utilizing a CSV file, data can be optimized within a table using indexes.\nIndexes can be utilized to speed up our queries. We can track the speed of our queries by executing .timer on in sqlite3. To understand how indexes can speed up our queries, run the following:\nSELECT * FROM shows WHERE title = \u0026#39;The Office\u0026#39;; Notice the time that displays after the query executes. Then, we can create an index with the syntax\nCREATE INDEX title_index on shows (title); This tells sqlite3 to create an index and perform some special under-the-hood optimization relating to this column title.\nThis will create a data structure called a B Tree, a data structure that looks similar to a binary tree. However, unlike a binary tree, there can be more than two child notes.\nRunning the query\nSELECT * FROM shows WHERE title = \u0026#39;The Office\u0026#39;; You will notice that the query runs much more quickly!\nUnfortunately, indexing all columns would result in utilizing more storage space. Therefore, there is a tradeoff for enhanced speed.\n"
},
{
	"uri": "//localhost:1313/3-sql-in-python/",
	"title": "SQL in Python",
	"tags": [],
	"description": "",
	"content": "To assist in working with SQL in this course, the CS50 Library can be utilized as follows in your code:\nfrom cs50 import SQL Similar to previous uses of the CS50 Library, this library will assist with the complicated steps of utilizing SQL within your Python code.\nYou can read more about the CS50 Libraryâ€™s SQL functionality in the documentation.\nRecall where we last left off in favorites.py. Your code should appear as follows:\n# Gets a specific count import csv from collections import Counter # Open CSV file with open(\u0026#34;favorites.csv\u0026#34;, \u0026#34;r\u0026#34;) as file: # Create DictReader reader = csv.DictReader(file) # Counts counts = Counter() # Iterate over CSV file, counting favorites for row in reader: favorite = row[\u0026#34;problem\u0026#34;] counts[favorite] += 1 # Print count favorite = input(\u0026#34;Favorite: \u0026#34;) print(f\u0026#34;{favorite}: {counts[favorite]}\u0026#34;) Modify your code as follows:\n# Searches database popularity of a problem import csv from cs50 import SQL # Open database db = SQL(\u0026#34;sqlite:///favorites.db\u0026#34;) # Prompt user for favorite favorite = input(\u0026#34;Favorite: \u0026#34;) # Search for title rows = db.execute(\u0026#34;SELECT COUNT(*) AS n FROM favorites WHERE problem LIKE ?\u0026#34;, favorite) # Get first (and only) row row = rows[0] # Print popularity print(row[\u0026#34;n\u0026#34;]) Notice that db = SQL(\u0026quot;sqlite:///favorites.db\u0026quot;) provide Python the location of the database file. Then, the line that begins with rows executes SQL commands utilizing db.execute. Indeed, this command passes the syntax within the quotation marks to the db.execute function. We can issue any SQL command using this syntax.\nFurther, notice that rows is returned as a list of dictionaries. In this case, there is only one result, one row, returned to the rows list as a dictionary.\nRace Conditions Utilization of SQL can sometimes result in some problems. You can imagine a case where multiple users could be accessing the same database and executing commands at the same time. This could result in glitches where code is interrupted by other peopleâ€™s actions. This could result in a loss of data. Built-in SQL features such as BEGIN TRANSACTION, COMMIT, and ROLLBACK help avoid some of these race condition problems.\n"
},
{
	"uri": "//localhost:1313/4-injection-attacks/",
	"title": "Injection Attacks",
	"tags": [],
	"description": "",
	"content": "One of the problems that can arise in real-world applications of SQL is what is called an injection attack. An injection attack is where a malicious actor could input malicious SQL code. For example, consider a login screen as follows:\nYou should never trust the users, do not use formatted strings as below to query:\nrows = db.execute(f\u0026#34;SELECT * FROM users WHERE username = \u0026#39;{username}\u0026#39; AND password = \u0026#39;{password}\u0026#39;\u0026#34;) Without the proper protections in our own code, a bad actor could run malicious code. Consider the following:\nrows = db.execute(\u0026#34;SELECT COUNT(*) FROM users WHERE username = ? AND password = ?\u0026#34;, username, password) Notice that because the ? is in place, validation can be run on favorite before it is blindly accepted by the query. You never want to utilize formatted strings in queries as above or blindly trust the userâ€™s input. Utilizing the CS50 Library, the library will sanitize and remove any potentially malicious characters.\nThat\u0026rsquo;s all of week 7 ^^\n"
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]